------

**EREDITARIETÀ MULTIPLA**
---
*final virtual : dopo quest'istruzione smette di essere virtual*

*Ambiguità*
	Il meccanismo dell'ereditarietà multipla può portare ad ambiguità nell'esecuzione:
```c++
#include <iostream>
using namespace std;
class SETTE{
private:
int Info;
public:
		SETTE(){ Info = 7; } 
		int GetInfo1(){ return Info; } 
};
class UNDICI{ 
private: 
	int Info;
public:
	UNDICI(){Info = 11;}
	int GetInfo2() { return Info; } 
}; 
class NUOVA: 
	public SETTE, public UNDICI { … };
};
int main(){
	NUOVA A;
	cout << A.GetInfo1() << endl;
	cout << A.GetInfo2() << endl;
}
```

*Ambiguità Private*
	In questo caso, i due attributi **Info**, benchè omonimi, sono istanziati *separatamente* e non producono sovrapposizione.
	L'accesso a ciascuna istanza avviene attraverso i metodi `GetInfo1()` e `GetInfo2()`, che restituisce i due valori di Info (7 e 11)

*Ambiguità Public*
	In questo caso, il compilatore non è in grado di stabilire quale dei due metodi base dev'essere invocato.
```c++
#include <iostream>
using namespace std;
class SETTE{
private:
	int Info;
public:
	SETTE(){ Info = 7; }
	int GetInfo(){ return Info; }
};
class UNDICI{
private:
	int Info;
public:
	UNDICI(){ Info = 11; }
	int GetInfo() { return Info; }
};
class NUOVA: public SETTE, public UNDICI { … };
int main(){ NUOVA A; cout << A.GetInfo() << endl;return 0;}
```

*Override Metodi*
	Una classe derivata può ridefinire funzioni già definite nella classe madre.
	In questo caso, la funzione originale è utilizzabile, tramite l'operatore di *scope* `::`

-----
**POLIMORFISMO**
---
*Assegnazione di un metodo ad un messaggio*
	I metodi pubblici della classe costituiscono l'interfaccia della classe, ovvero i *messaggi che la classe può interpretare*.
	La funzione è assegnata al messaggio in fase di codifica *early binding*, ma può essere necessario assegnarla a run-time *late binding*

*Polimorfismo*
	La possibilità che le classi derivate implementano in modo differente i metodi e le proprietà dei propri antenati rende possibile che gli oggetti appartenenti a sottoclassi rispondano diversamente alle stesse istruzioni. Tale eventualità viene detta *polimorfismo*
	I metodi che vengono ridefiniti in una sottoclasse sono detti *polimorfi*

*Binding Dinamico*
	Il polimorfismo è particolarmente utile quando la *versione del metodo da eseguire viene scelta sulla base del tipo di oggetto contenuto in una variabile* a runtime, invece che al momento della compilazione. Tale funzionalità è detta **binding dinamico**.
	Ad esempio, potremmo avere 3 classi A e le sottoclassi B,C che ridefiniscono il metodo `m()` ,  quando sulla variabile viene invocato il metodo `m()` viene eseguita la versione appropriata per il tipo di oggetto contenuto nella variabile.
	In C++, il binding dinamico ed il polimorfismo, si ottengono solamente:
		*Dichiarando i metodi polimorfi **virtual***.
		*Operando tramite **puntatori e riferimenti***
```c++
#include <iostream>
class B{
public:
	virtual void bar(){};
	virtual void qux(){};
};
class C : public B{
public:
	void bar() override{};
};
```

*Controllo dei tipi*
	Controllare i tipi significa verificare che ad un oggetto vengano inviati solo messaggi che è in grado di comprendere:
		Controllo del *nome* del metodo
		Controllo della *lista* degli argomenti

*Upcasting & Object Slicing*
	Un oggetto di una classe derivata può essere implicitamente convertito in un oggetto della classe base.
	Questa operazione è detta **upcasting**, dato che ci si muove *in alto nella gerarchia*.
	L'upcasting però produce **object slicing**, con perdita dei dati membro definiti a livello della derivata. Ad esempio, un oggetto della classe *Point3D* può essere convertito in un oggetto della classe *Point*, ma perderebbe l'attributo *z*
```c++
#include <iostream>
#include <string>
using namespace std;

class Persona {
public:
	Persona(string s): nome(s) { } 
	virtual void Print() { cout << "Il mio nome e' " << nome << endl; }
protected: 
	string nome;
};
class Studente : public Persona {
public:
	Studente(string s, float g):Persona(s), media(g) { }
	void Print(){
		cout << "Il mio nome è " << nome << " e la mia media è “<< media << endl;
	}
private:
	float media;
};
class Professore : public Persona { 
public: 
	Professore(string s, int n):Persona(s),pubblicazioni(n) { }
	void Print() {
		cout << "Il mio nome e' " << nome << " ed ho " << pubblicazioni;
		cout << " pubblicazioni" << endl;
	}
private:
	int pubblicazioni;
}; 
int main() { 
	Persona* p; 
	Persona x(string("Giuseppe")); 
	p = &x;
	p->Print();
	Studente y(string("Giovanni"), 21);
	p = &y;
	p->Print();
	Professore z(string("Antonio"), 7);
	p = &z;
	p->Print();
	return 0;
}
```

*Classi Base Astratte*
	Le classi che hanno qualche funzione membro *virtuale* sono dette **astratte**
	Le classi astratte *non sono istanziabili*, ed esistono solo come classi base da cui derivare altre classi.
	Esse sono la maniera migliore di rappresentare le principali interfacce di un sistema SW:
		*Rendono possibile l'uso simultaneo di molte implementazioni differenti del concetto*, rappresentato dall'interfaccia
		*Isolano completamente gli utenti* dalle modifiche nelle implementazioni.

---
**OVERLOADING OPERATORI**
---
